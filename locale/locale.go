// This file was generated by the 'generate' command. Do not edit.
// CLDR version: 44

package locale

import (
	"github.com/liblxn/lxnc/internal/errors"
	"sort"
)

const root Locale = 965

// Locale represents a reference to the data of a CLDR locale.
type Locale tagID

// New looks up a locale from the given tag (e.g. "en-US"). If the tag is
// malformed or cannot be found in the CLDR specification, an error will
// be returned.
func New(tag string) (Locale, error) {
	var p localeTagParser
	if err := p.parse(tag); err != nil {
		return 0, err
	}

	lang := langTags.langID(p.lang)
	script := scriptTags.scriptID(p.script)
	region := regionTags.regionID(p.region)
	switch {
	case lang == 0:
		return 0, errors.Newf("unsupported language: %s", p.lang)
	case len(p.script) != 0 && script == 0:
		return 0, errors.Newf("unsupported script: %s", p.script)
	}

	var tagID tagID
	if len(p.region) == 0 || region != 0 {
		tagID = localeTags.tagID(lang, script, region)
	}
	if tagID == 0 && len(p.region) != 0 {
		var parents [2]regionID
		nparents := regionContainments.containmentIDs(p.region, parents[:])
		if nparents == 0 && region == 0 {
			return 0, errors.Newf("unsupported region: %s", p.region)
		}

		for i := 0; i < nparents; i++ {
			if tagID = localeTags.tagID(lang, script, parents[i]); tagID != 0 {
				break
			}
		}
	}

	if tagID == 0 {
		return 0, errors.Newf("locale not found: %s", tag)
	}
	return Locale(tagID), nil
}

// Subtags returns the language, script, and region subtags of the locale. If one
// of the subtags are not specified, an empty string will be returned for this subtag.
func (l Locale) Subtags() (lang string, script string, region string) {
	langID, scriptID, regionID := l.tagIDs()
	if langID != 0 {
		lang = langTags.lang(langID)
	} else {
		lang = "und"
	}
	if scriptID != 0 {
		script = scriptTags.script(scriptID)
	}
	if regionID != 0 {
		region = regionTags.region(regionID)
	}
	return
}

// String returns the string represenation of the locale.
func (l Locale) String() string {
	const sep = '-'
	var buf [12]byte

	lang, script, region := l.Subtags()
	n := copy(buf[:], lang)
	if script != "" {
		buf[n] = sep
		n++
		n += copy(buf[n:], script)
	}
	if region != "" {
		buf[n] = sep
		n++
		n += copy(buf[n:], region)
	}
	return string(buf[:n])
}

func (l Locale) tagIDs() (langID, scriptID, regionID) {
	tag := localeTags.tag(tagID(l))
	return tag.langID(), tag.scriptID(), tag.regionID()
}

func (l Locale) parent() Locale {
	if parentID := parentLocaleTags.parentID(tagID(l)); parentID != 0 {
		return Locale(parentID)
	}

	// truncate locale
	langID, scriptID, regionID := l.tagIDs()
	if regionID != 0 {
		regionID = 0
		if tid := localeTags.tagID(langID, scriptID, regionID); tid != 0 {
			return Locale(tid)
		}
	}
	if scriptID != 0 {
		scriptID = 0
		if tid := localeTags.tagID(langID, scriptID, regionID); tid != 0 {
			return Locale(tid)
		}
	}
	return root
}

type localeTagParser struct {
	s   string
	tok string
	idx int
	buf [10]byte

	lang   []byte
	script []byte
	region []byte
}

func (p *localeTagParser) parse(tag string) error {
	if tag == "" {
		return errors.New("empty locale tag")
	}

	p.s = tag
	p.idx = 0
	p.next()

	p.lang = p.parseLang()
	if len(p.lang) == 0 {
		if len(p.tok) == 0 {
			return errors.Newf("malformed locale tag: %s", tag)
		}
		return errors.Newf("invalid language subtag: %s", p.tok)
	}
	p.script = p.parseScript()
	p.region = p.parseRegion()

	if len(p.tok) != 0 {
		return errors.Newf("unsupported locale suffix: %s", p.s[p.idx:])
	}
	return nil
}

func (p *localeTagParser) parseLang() []byte {
	var lang []byte
	switch len(p.tok) {
	case 2: // alpha{2}
		lang = p.buf[:2]
		lang[0] = p.tok[0] | 0x20 // lowercase
		lang[1] = p.tok[1] | 0x20 // lowercase
	case 3: // alpha{3}
		lang = p.buf[:3]
		lang[0] = p.tok[0] | 0x20 // lowercase
		lang[1] = p.tok[1] | 0x20 // lowercase
		lang[2] = p.tok[2] | 0x20 // lowercase
	default:
		return nil
	}
	p.next()
	return lang
}

func (p *localeTagParser) parseScript() []byte {
	if len(p.tok) != 4 {
		return nil
	}
	script := p.buf[3:7]
	script[0] = p.tok[0] & 0xdf // uppercase
	script[1] = p.tok[1] | 0x20 // lowercase
	script[2] = p.tok[2] | 0x20 // lowercase
	script[3] = p.tok[3] | 0x20 // lowercase
	p.next()
	return script
}

func (p *localeTagParser) parseRegion() []byte {
	var region []byte
	switch len(p.tok) {
	case 2: // alpha{2}
		region = p.buf[7:9]
		region[0] = p.tok[0] & 0xdf // uppercase
		region[1] = p.tok[1] & 0xdf // uppercase
	case 3: // digit{3}
		region = p.buf[7:10]
		region[0] = p.tok[0]
		region[1] = p.tok[1]
		region[2] = p.tok[2]
	default:
		return nil
	}
	p.next()
	return region
}

func (p *localeTagParser) next() {
	start := p.idx
	for p.idx < len(p.s) {
		if c := p.s[p.idx]; c == '-' || c == '_' {
			p.tok = p.s[start:p.idx]
			p.idx++
			return
		}
		p.idx++
	}
	p.tok = p.s[start:p.idx]
}

// A tag is a tuple consisting of language subtag, the script subtag,
// and the region subtag. The tag lookup is an ordered list of tags and the
// tag id is an 1-based index of this list.
type tag uint32

func (t tag) langID() langID {
	return langID((t >> 16) & 0xffff)
}

func (t tag) scriptID() scriptID {
	return scriptID((t >> 8) & 0xff)
}

func (t tag) regionID() regionID {
	return regionID(t & 0xff)
}

type tagID uint16

type tagLookup []tag

func (l tagLookup) tag(id tagID) tag {
	if id == 0 || int(id) > len(l) {
		return 0
	}
	return l[id-1]
}

func (l tagLookup) tagID(lang langID, script scriptID, region regionID) tagID {
	t := (tag(lang) << 16) | (tag(script) << 8) | tag(region)
	idx := sort.Search(len(l), func(i int) bool {
		return l[i] >= t
	})

	if idx < len(l) && l[idx] == t {
		return tagID(idx + 1)
	}
	return 0
}

// A lang id is an identifier of a specific fixed-width string and defines
// a 1-based index into a lookup string. The lookup consists of concatenated
// blocks of size 3, where each block contains a lang string.
type langID uint16

type langLookup string

func (l langLookup) lang(id langID) string {
	if id == 0 || 3*int(id) > len(l) {
		return ""
	}

	code := l[int(id-1)*3 : int(id)*3]
	end := 3
	for end > 0 && code[end-1] == ' ' {
		end--
	}
	return string(code[:end])
}

func (l langLookup) langID(str []byte) langID {
	idx := sort.Search(len(l)/3, func(i int) bool {
		return l[i*3:(i+1)*3] >= langLookup(str)
	})

	if idx*3 < len(l) && l.lang(langID(idx+1)) == string(str) {
		return langID(idx + 1)
	}
	return 0
}

// A script id is an identifier of a specific fixed-width string and defines
// a 1-based index into a lookup string. The lookup consists of concatenated
// blocks of size 4, where each block contains a script string.
type scriptID uint8

type scriptLookup string

func (l scriptLookup) script(id scriptID) string {
	if id == 0 || 4*int(id) > len(l) {
		return ""
	}

	code := l[int(id-1)*4 : int(id)*4]
	end := 4
	for end > 0 && code[end-1] == ' ' {
		end--
	}
	return string(code[:end])
}

func (l scriptLookup) scriptID(str []byte) scriptID {
	idx := sort.Search(len(l)/4, func(i int) bool {
		return l[i*4:(i+1)*4] >= scriptLookup(str)
	})

	if idx*4 < len(l) && l.script(scriptID(idx+1)) == string(str) {
		return scriptID(idx + 1)
	}
	return 0
}

// A region id is an identifier of a specific fixed-width string and defines
// a 1-based index into a lookup string. The lookup consists of concatenated
// blocks of size 3, where each block contains a region string.
type regionID uint8

type regionLookup string

func (l regionLookup) region(id regionID) string {
	if id == 0 || 3*int(id) > len(l) {
		return ""
	}

	code := l[int(id-1)*3 : int(id)*3]
	end := 3
	for end > 0 && code[end-1] == ' ' {
		end--
	}
	return string(code[:end])
}

func (l regionLookup) regionID(str []byte) regionID {
	idx := sort.Search(len(l)/3, func(i int) bool {
		return l[i*3:(i+1)*3] >= regionLookup(str)
	})

	if idx*3 < len(l) && l.region(regionID(idx+1)) == string(str) {
		return regionID(idx + 1)
	}
	return 0
}

// A region containment is a tuple consisting of a 2-letter region code and
// a list of region subtag ids. The lookup maps an alphabetic region code (the child)
// to a list of containing regions (the parents). Each entry in the mapping is
// encoded as "RR\xnn\xp1...\xpn", where RR is the child region code, n the number
// of parent subtag ids and p1, ..., pn the parent subtag ids.
type regionContainmentLookup string

func (l regionContainmentLookup) containmentIDs(region []byte, parents []regionID) int {
	// The length of parents specifies the number of containment ids per block.
	if len(region) != 2 {
		return 0
	}
	blocksize := 2 + 1*len(parents)
	idx := sort.Search(len(l)/blocksize, func(i int) bool {
		i *= blocksize
		return l[i:i+2] >= regionContainmentLookup(region)
	})

	idx *= blocksize
	if idx < len(l) && l[idx:idx+2] == regionContainmentLookup(region) {
		for i := 0; i < len(parents); i++ {
			start := idx + i
			parents[i] = regionID(l[start+2])
			if parents[i] == 0 {
				return i
			}
		}
		return len(parents)
	}
	return 0
}

// The parent tag lookup is an ordered list of tag id pairs. Each pair consists
// of a child id and a parent id.
type parentTagLookup []uint32 // tag id => tag id

func (l parentTagLookup) parentID(child tagID) tagID {
	idx := sort.Search(len(l), func(i int) bool {
		return tagID(l[i]>>16) >= child
	})
	if idx < len(l) && tagID(l[idx]>>16) == child {
		return tagID(l[idx] & 0xffff)
	}
	return 0
}
